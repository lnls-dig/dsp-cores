-- -------------------------------------------------------------
--
-- Module: hpf_adcinput
-- Generated by MATLAB(R) 8.3 and the Filter Design HDL Coder 2.9.5.
-- Generated on: 2019-11-20 23:00:25
-- -------------------------------------------------------------

-- -------------------------------------------------------------
-- HDL Code Generation Options:
--
-- TargetLanguage: VHDL
-- ResetType: Synchronous
-- FoldingFactor: 12
-- ClockEnableInputPort: ce_i
-- ClockInputPort: clk_i
-- ResetInputPort: rst_n_i
-- UseRisingEdge: on
-- TargetDirectory: /home/danielot/hdlsrc
-- EDAScriptGeneration: off
-- InputPort: data_i
-- OutputPort: data_o
-- Name: hpf_adcinput
-- TestBenchStimulus: step ramp chirp 
-- GenerateHDLTestBench: off

-- Filter Specifications:
--
-- Sample Rate     : N/A (normalized frequency)
-- Response        : Highpass
-- Specification   : Fst,Fp,Ast,Ap
-- Stopband Edge   : 0.045266
-- Passband Edge   : 0.36213
-- Stopband Atten. : 40 dB
-- Passband Ripple : 1 dB
-- -------------------------------------------------------------

-- -------------------------------------------------------------
-- HDL Implementation    : Fully Serial
-- Multipliers           : 1
-- Folding Factor        : 12
-- -------------------------------------------------------------
-- Filter Settings:
--
-- Discrete-Time IIR Filter (real)
-- -------------------------------
-- Filter Structure    : Direct-Form II, Second-Order Sections
-- Number of Sections  : 2
-- Stable              : Yes
-- Linear Phase        : No
-- Arithmetic          : fixed
-- Numerator           : s16,14 -> [-2 2)
-- Denominator         : s16,14 -> [-2 2)
-- Scale Values        : s16,15 -> [-1 1)
-- Input               : s16,15 -> [-1 1)
-- Section Input       : s16,10 -> [-32 32)
-- Section Output      : s16,11 -> [-16 16)
-- Output              : s16,11 -> [-16 16)
-- State               : s16,15 -> [-1 1)
-- Numerator Prod      : s32,29 -> [-4 4)
-- Denominator Prod    : s32,29 -> [-4 4)
-- Numerator Accum     : s34,29 -> [-16 16)
-- Denominator Accum   : s34,29 -> [-16 16)
-- Round Mode          : convergent
-- Overflow Mode       : wrap
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.ALL;

ENTITY hpf_adcinput IS
   PORT( clk_i                           :   IN    std_logic; 
         ce_i                            :   IN    std_logic; 
         rst_n_i                           :   IN    std_logic; 
         data_i                          :   IN    std_logic_vector(15 DOWNTO 0); -- sfix16_En15
         data_o                          :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En11
         );

END hpf_adcinput;


----------------------------------------------------------------
--Module Architecture: hpf_adcinput
----------------------------------------------------------------
ARCHITECTURE rtl OF hpf_adcinput IS
  -- Local Functions
  -- Type Definitions
  TYPE delay_pipeline_type IS ARRAY (NATURAL range <>) OF signed(15 DOWNTO 0); -- sfix16_En15
  -- Constants
  CONSTANT scaleconst1                    : signed(17 DOWNTO 0) := to_signed(18503, 18); -- sfix18_En15
  CONSTANT coeff_b1_section1              : signed(17 DOWNTO 0) := to_signed(32768, 18); -- sfix18_En15
  CONSTANT coeff_b2_section1              : signed(17 DOWNTO 0) := to_signed(-65536, 18); -- sfix18_En15
  CONSTANT coeff_b3_section1              : signed(17 DOWNTO 0) := to_signed(32768, 18); -- sfix18_En15
  CONSTANT coeff_a2_section1              : signed(17 DOWNTO 0) := to_signed(-27366, 18); -- sfix18_En15
  CONSTANT coeff_a3_section1              : signed(17 DOWNTO 0) := to_signed(13880, 18); -- sfix18_En15
  CONSTANT scaleconst2                    : signed(17 DOWNTO 0) := to_signed(21695, 18); -- sfix18_En15
  CONSTANT coeff_b1_section2              : signed(17 DOWNTO 0) := to_signed(32768, 18); -- sfix18_En15
  CONSTANT coeff_b2_section2              : signed(17 DOWNTO 0) := to_signed(-32768, 18); -- sfix18_En15
  CONSTANT coeff_b3_section2              : signed(17 DOWNTO 0) := to_signed(0, 18); -- sfix18_En15
  CONSTANT coeff_a2_section2              : signed(17 DOWNTO 0) := to_signed(-10622, 18); -- sfix18_En15
  CONSTANT coeff_a3_section2              : signed(17 DOWNTO 0) := to_signed(0, 18); -- sfix18_En15
  -- Signals
  SIGNAL input_register                   : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL cur_count                        : unsigned(3 DOWNTO 0); -- ufix4
  SIGNAL phase_0                          : std_logic; -- boolean
  SIGNAL phase_2                          : std_logic; -- boolean
  SIGNAL phase_3                          : std_logic; -- boolean
  SIGNAL phase_5                          : std_logic; -- boolean
  SIGNAL phase_6                          : std_logic; -- boolean
  SIGNAL phase_8                          : std_logic; -- boolean
  SIGNAL phase_9                          : std_logic; -- boolean
  SIGNAL phase_11                         : std_logic; -- boolean
  SIGNAL sectionipconvert                 : signed(15 DOWNTO 0); -- sfix16_En10
  SIGNAL storagetypeconvert               : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL prev_stg_op1                     : signed(15 DOWNTO 0); -- sfix16_En11
  SIGNAL storage_state_in1                : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL delay_section1                   : delay_pipeline_type(0 TO 1); -- sfix16_En15
  SIGNAL storage_state_in2                : signed(15 DOWNTO 0); -- sfix16_En15
  SIGNAL delay_section2                   : delay_pipeline_type(0 TO 1); -- sfix16_En15
  SIGNAL input_section1_cast              : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL storage_in_section1_cast         : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL delay_section11_cast             : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL delay_section12_cast             : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL input_section2_cast              : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL storage_in_section2_cast         : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL delay_section21_cast             : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL delay_section22_cast             : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL inputmux_section_1               : signed(19 DOWNTO 0); -- sfix20_En15
  SIGNAL coeffmux_section_1               : signed(17 DOWNTO 0); -- sfix18_En15
  SIGNAL prod                             : signed(37 DOWNTO 0); -- sfix38_En30
  SIGNAL prod_den                         : signed(31 DOWNTO 0); -- sfix32_En29
  SIGNAL prod_den_cast_temp               : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL prod_den_cast                    : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL prod_den_cast_neg                : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL unaryminus_temp                  : signed(34 DOWNTO 0); -- sfix35_En29
  SIGNAL prod_num                         : signed(31 DOWNTO 0); -- sfix32_En29
  SIGNAL prod_num_cast_temp               : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL prod_num_cast                    : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL accum_mux_in1                    : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL accum_mux_in2                    : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL accum_mux_out                    : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL accum_mux_in1_temp               : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL sectionipconvert_cast            : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL final_phase                      : std_logic; -- boolean
  SIGNAL section_phase                    : std_logic; -- boolean
  SIGNAL accum_reg                        : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL add_cast                         : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL add_cast_1                       : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL add_temp                         : signed(34 DOWNTO 0); -- sfix35_En29
  SIGNAL acc_out_cast_numacc              : signed(33 DOWNTO 0); -- sfix34_En29
  SIGNAL sectionopconvert                 : signed(15 DOWNTO 0); -- sfix16_En11
  SIGNAL output_typeconvert               : signed(15 DOWNTO 0); -- sfix16_En11
  SIGNAL output_register                  : signed(15 DOWNTO 0); -- sfix16_En11


BEGIN

  -- Block Statements
  input_reg_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        input_register <= (OTHERS => '0');
      ELSIF ce_i = '1' THEN
        input_register <= signed(data_i);
      END IF;
    END IF; 
  END PROCESS input_reg_process;

  Counter_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        cur_count <= to_unsigned(0, 4);
      ELSIF ce_i = '1' THEN
        IF cur_count = to_unsigned(11, 4) THEN
          cur_count <= to_unsigned(0, 4);
        ELSE
          cur_count <= cur_count + 1;
        END IF;
      END IF;
    END IF; 
  END PROCESS Counter_process;

  phase_0 <= '1' WHEN cur_count = to_unsigned(0, 4) AND ce_i = '1' ELSE '0';

  phase_2 <= '1' WHEN cur_count = to_unsigned(2, 4) AND ce_i = '1' ELSE '0';

  phase_3 <= '1' WHEN cur_count = to_unsigned(3, 4) AND ce_i = '1' ELSE '0';

  phase_5 <= '1' WHEN cur_count = to_unsigned(5, 4) AND ce_i = '1' ELSE '0';

  phase_6 <= '1' WHEN cur_count = to_unsigned(6, 4) AND ce_i = '1' ELSE '0';

  phase_8 <= '1' WHEN cur_count = to_unsigned(8, 4) AND ce_i = '1' ELSE '0';

  phase_9 <= '1' WHEN cur_count = to_unsigned(9, 4) AND ce_i = '1' ELSE '0';

  phase_11 <= '1' WHEN cur_count = to_unsigned(11, 4) AND ce_i = '1' ELSE '0';


  -- Next stage input = Previous stage output. Storing Previous stage output
  prev_stg_op1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        prev_stg_op1 <= (OTHERS => '0');
      ELSIF phase_5 = '1' THEN
        prev_stg_op1 <= sectionopconvert;
      END IF;
    END IF; 
  END PROCESS prev_stg_op1_process;

  delay_process_section1 : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        delay_section1 <= (OTHERS => (OTHERS => '0'));
      ELSIF phase_0 = '1' THEN
        delay_section1(1) <= delay_section1(0);
        delay_section1(0) <= storage_state_in1;
      END IF;
    END IF;
  END PROCESS delay_process_section1;

  delay_process_section2 : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        delay_section2 <= (OTHERS => (OTHERS => '0'));
      ELSIF phase_0 = '1' THEN
        delay_section2(1) <= delay_section2(0);
        delay_section2(0) <= storage_state_in2;
      END IF;
    END IF;
  END PROCESS delay_process_section2;

  -- Making common precision for input and state 
  input_section1_cast <= resize(input_register, 20);

  delay_section11_cast <= resize(delay_section1(0), 20);

  delay_section12_cast <= resize(delay_section1(1), 20);

  storage_in_section1_cast <= resize(storage_state_in1, 20);

  delay_section11_cast <= resize(delay_section1(0), 20);

  delay_section12_cast <= resize(delay_section1(1), 20);

  input_section2_cast <= resize(prev_stg_op1(15 DOWNTO 0) & '0' & '0' & '0' & '0', 20);

  delay_section21_cast <= resize(delay_section2(0), 20);

  delay_section22_cast <= resize(delay_section2(1), 20);

  storage_in_section2_cast <= resize(storage_state_in2, 20);

  delay_section21_cast <= resize(delay_section2(0), 20);

  delay_section22_cast <= resize(delay_section2(1), 20);

  inputmux_section_1 <= input_section1_cast WHEN ( cur_count = to_unsigned(0, 4) ) ELSE
                             delay_section11_cast WHEN ( cur_count = to_unsigned(1, 4) ) ELSE
                             delay_section12_cast WHEN ( cur_count = to_unsigned(2, 4) ) ELSE
                             storage_in_section1_cast WHEN ( cur_count = to_unsigned(3, 4) ) ELSE
                             delay_section11_cast WHEN ( cur_count = to_unsigned(4, 4) ) ELSE
                             delay_section12_cast WHEN ( cur_count = to_unsigned(5, 4) ) ELSE
                             input_section2_cast WHEN ( cur_count = to_unsigned(6, 4) ) ELSE
                             delay_section21_cast WHEN ( cur_count = to_unsigned(7, 4) ) ELSE
                             delay_section22_cast WHEN ( cur_count = to_unsigned(8, 4) ) ELSE
                             storage_in_section2_cast WHEN ( cur_count = to_unsigned(9, 4) ) ELSE
                             delay_section21_cast WHEN ( cur_count = to_unsigned(10, 4) ) ELSE
                             delay_section22_cast;

  coeffmux_section_1 <= scaleconst1 WHEN ( cur_count = to_unsigned(0, 4) ) ELSE
                             coeff_a2_section1 WHEN ( cur_count = to_unsigned(1, 4) ) ELSE
                             coeff_a3_section1 WHEN ( cur_count = to_unsigned(2, 4) ) ELSE
                             coeff_b1_section1 WHEN ( cur_count = to_unsigned(3, 4) ) ELSE
                             coeff_b2_section1 WHEN ( cur_count = to_unsigned(4, 4) ) ELSE
                             coeff_b3_section1 WHEN ( cur_count = to_unsigned(5, 4) ) ELSE
                             scaleconst2 WHEN ( cur_count = to_unsigned(6, 4) ) ELSE
                             coeff_a2_section2 WHEN ( cur_count = to_unsigned(7, 4) ) ELSE
                             coeff_a3_section2 WHEN ( cur_count = to_unsigned(8, 4) ) ELSE
                             coeff_b1_section2 WHEN ( cur_count = to_unsigned(9, 4) ) ELSE
                             coeff_b2_section2 WHEN ( cur_count = to_unsigned(10, 4) ) ELSE
                             coeff_b3_section2;

  prod <= inputmux_section_1 * coeffmux_section_1;

  prod_den <= resize(shift_right(prod(32 DOWNTO 0) + ( "0" & (prod(1))), 1), 32);

  prod_den_cast_temp <= resize(prod_den, 34);

  prod_den_cast <= prod_den_cast_temp;

  unaryminus_temp <= ('0' & prod_den_cast) WHEN prod_den_cast = "1000000000000000000000000000000000"
      ELSE -resize(prod_den_cast,35);
  prod_den_cast_neg <= unaryminus_temp(33 DOWNTO 0);

  prod_num <= resize(shift_right(prod(32 DOWNTO 0) + ( "0" & (prod(1))), 1), 32);

  prod_num_cast_temp <= resize(prod_num, 34);

  prod_num_cast <= prod_num_cast_temp;

  accum_mux_in1 <= prod_num_cast WHEN ( cur_count = to_unsigned(0, 4) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(1, 4) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(2, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(3, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(4, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(5, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(6, 4) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(7, 4) ) ELSE
                        prod_den_cast_neg WHEN ( cur_count = to_unsigned(8, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(9, 4) ) ELSE
                        prod_num_cast WHEN ( cur_count = to_unsigned(10, 4) ) ELSE
                        prod_num_cast;

  final_phase <=  phase_0 OR phase_3 OR phase_6 OR phase_9;

  section_phase <=  phase_0 OR phase_6;

  accum_mux_in1_temp <= sectionipconvert_cast WHEN ( section_phase = '1' ) ELSE
                             accum_mux_in1;

  accum_mux_out <= accum_mux_in1_temp WHEN ( final_phase = '1' ) ELSE
                        accum_mux_in2;

  accumulator_reg_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        accum_reg <= (OTHERS => '0');
      ELSIF ce_i = '1' THEN
        accum_reg <= accum_mux_out;
      END IF;
    END IF; 
  END PROCESS accumulator_reg_process;

  add_cast <= accum_reg;
  add_cast_1 <= accum_mux_in1;
  add_temp <= resize(add_cast, 35) + resize(add_cast_1, 35);
  accum_mux_in2 <= add_temp(33 DOWNTO 0);

  storagetypeconvert <= resize(shift_right(accum_mux_out(29 DOWNTO 0) + ( "0" & (accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14) & NOT accum_mux_out(14))), 14), 16);

  sectionipconvert <= resize(shift_right(prod(35 DOWNTO 0) + ( "0" & (prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20) & NOT prod(20))), 20), 16);

  sectionipconvert_cast <= resize(sectionipconvert(14 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 34);

  acc_out_cast_numacc <= accum_mux_out;

  sectionopconvert <= resize(shift_right(acc_out_cast_numacc(33 DOWNTO 0) + ( "0" & (acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18))), 18), 16);

  output_typeconvert <= resize(shift_right(acc_out_cast_numacc(33 DOWNTO 0) + ( "0" & (acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18) & NOT acc_out_cast_numacc(18))), 18), 16);

  storage_reg1_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        storage_state_in1 <= (OTHERS => '0');
      ELSIF phase_2 = '1' THEN
        storage_state_in1 <= storagetypeconvert;
      END IF;
    END IF; 
  END PROCESS storage_reg1_process;

  storage_reg2_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        storage_state_in2 <= (OTHERS => '0');
      ELSIF phase_8 = '1' THEN
        storage_state_in2 <= storagetypeconvert;
      END IF;
    END IF; 
  END PROCESS storage_reg2_process;

  Output_Register_process : PROCESS (clk_i)
  BEGIN
    IF rising_edge(clk_i) THEN
      IF rst_n_i = '0' THEN
        output_register <= (OTHERS => '0');
      ELSIF phase_11 = '1' THEN
        output_register <= output_typeconvert;
      END IF;
    END IF; 
  END PROCESS Output_Register_process;

  -- Assignment Statements
  data_o <= std_logic_vector(output_register);
END rtl;
